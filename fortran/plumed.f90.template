! vim:ft=fortran
#:include 'defs.fypp'

module plumed_module
  use iso_c_binding
  implicit none

  private
  public :: plumed_f_create
  public :: plumed_f_create_dlopen
  public :: plumed_f_create_reference
  public :: plumed_f_create_invalid
  public :: plumed_f_cmd
  public :: plumed_f_finalize
  public :: plumed_f_installed
  public :: plumed_f_valid
  public :: plumed_f_use_count
  public :: plumed_f_global
  public :: plumed_f_ginitialized
  public :: plumed_f_gcreate
  public :: plumed_f_gcmd
  public :: plumed_f_gfinalize
  public :: plumed_f_gvalid
  public :: plumed_error

  type :: plumed_error
    integer                         :: code=0
    character(len = :), allocatable :: what
  end type plumed_error

  type :: dummy_type
  end type dummy_type

  interface
    subroutine plumed_f_create(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create
  end interface

  interface
    subroutine plumed_f_create_dlopen(path,c) bind(C)
      import
      character(kind=c_char), intent(in)  :: path(*)
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_dlopen
  end interface

  interface
    subroutine plumed_f_create_reference(r,c) bind(C)
      import
      character(kind=c_char), intent(in)  :: r(32)
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_reference
  end interface

  interface
    subroutine plumed_f_create_invalid(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_invalid
  end interface

  interface
    subroutine plumed_f_finalize(c) bind(C)
      import
      character(kind=c_char), intent(in) :: c(32)
    end subroutine plumed_f_finalize
  end interface

  interface
    subroutine plumed_f_installed(i) bind(C)
      import
      integer(kind=c_int), intent(out) :: i
    end subroutine plumed_f_installed
  end interface

  interface
    subroutine plumed_f_valid(c,i) bind(C)
      import
      character(kind=c_char), intent(in) :: c(32)
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_valid
  end interface

  interface
    subroutine plumed_f_use_count(c,i) bind(C)
      import
      character(kind=c_char), intent(in)  :: c(32)
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_use_count
  end interface

  interface
    subroutine plumed_f_global(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_global
  end interface 

  interface
    subroutine plumed_f_ginitialized(i) bind(C)
      import
      integer(kind=c_int), intent(out) :: i
    end subroutine plumed_f_ginitialized
  end interface

  interface
    subroutine plumed_f_gcreate() bind(C)
    end subroutine plumed_f_gcreate
  end interface
  
  interface
    subroutine plumed_f_gfinalize() bind(C)
    end subroutine plumed_f_gfinalize
  end interface

  interface
    subroutine plumed_f_gvalid(i) bind(C)
      import
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_gvalid
  end interface

  interface
    subroutine plumed_f_cmd_safe_nothrow_ptr(p,key,val,pass_shape,const,nocopy,e,eh) bind(C)
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      type(c_ptr),                    value :: val
      integer(kind=c_size_t) :: pass_shape(*)
      integer(kind=c_int),            value :: const
      integer(kind=c_int),            value :: nocopy
      type(c_ptr),                    value :: e
      type(c_funptr),                 value :: eh
    end subroutine plumed_f_cmd_safe_nothrow_ptr
  end interface

  interface
    subroutine plumed_f_cmd_safe_nothrow_char(p,key,val,pass_shape,const,nocopy,e,eh) bind(C)
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      character(kind=c_char)                :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
      integer(kind=c_int),            value :: const
      integer(kind=c_int),            value :: nocopy
      type(c_ptr),                    value :: e
      type(c_funptr),                 value :: eh
    end subroutine plumed_f_cmd_safe_nothrow_char
  end interface

  interface plumed_f_cmd
    module procedure plumed_f_cmd_ptr
    module procedure plumed_f_cmd_char
#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    module procedure plumed_f_cmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor
  end interface plumed_f_cmd

  interface plumed_f_gcmd
    module procedure plumed_f_gcmd_ptr
    module procedure plumed_f_gcmd_char
#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    module procedure plumed_f_gcmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor
  end interface plumed_f_gcmd

#: for t in types
#: for k in kinds[t]
  interface
    subroutine plumed_f_cmd_safe_nothrow_${cname(k)}$_scalar(p,key,val,pass_shape,const,nocopy,e,eh) bind(C,name="plumed_f_cmd_safe_nothrow_${cname(k)}$")
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val
      integer(kind=c_size_t) :: pass_shape(*)
      integer(kind=c_int),            value :: const
      integer(kind=c_int),            value :: nocopy
      type(c_ptr),                    value :: e
      type(c_funptr),                 value :: eh
    end subroutine plumed_f_cmd_safe_nothrow_${cname(k)}$_scalar
  end interface
  interface
    subroutine plumed_f_cmd_safe_nothrow_${cname(k)}$(p,key,val,pass_shape,const,nocopy,e,eh) bind(C,name="plumed_f_cmd_safe_nothrow_${cname(k)}$")
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
      integer(kind=c_int),            value :: const
      integer(kind=c_int),            value :: nocopy
      type(c_ptr),                    value :: e
      type(c_funptr),                 value :: eh
    end subroutine plumed_f_cmd_safe_nothrow_${cname(k)}$
  end interface
#: endfor
#: endfor

  contains

     subroutine plumed_f_eh(error_ptr,code,what_ptr,opt_ptr) bind(C)
       type(c_ptr),         value :: error_ptr
       integer(kind=c_int), value :: code
       type(c_ptr),         value :: what_ptr
       type(c_ptr),         value :: opt_ptr
       type(plumed_error), pointer :: error
       character(len=1, kind=C_CHAR), pointer :: p_chars(:)
       integer :: i,j
       call c_f_pointer(error_ptr,error)
       error%code=code
       if (.not. C_associated(what_ptr)) then
         error%what=""
       else
         call C_F_pointer(what_ptr, p_chars, [huge(0)])
         do i = 1, huge(0)
           if (p_chars(i) == C_NULL_CHAR) exit
         enddo
         allocate(character(i-1) :: error%what)
         do j = 1,i-1
           error%what(j:j)=p_chars(j)
         enddo
       endif
     end subroutine plumed_f_eh

     subroutine plumed_f_cmd_ptr(p,key,val,dummy,error,ierror,const,nocopy)
       character(kind=c_char,len=32), intent(in)    :: p
       character(kind=c_char,len=*),  intent(in)    :: key
       type(c_ptr),                     value       :: val
       type(dummy_type),   optional                 :: dummy
       type(plumed_error), optional,  intent(out)   :: error
       integer,            optional,  intent(out)   :: ierror
       logical,            optional,  intent(in)    :: const
       logical,            optional,  intent(in)    :: nocopy
       type(plumed_error), target :: myerror
       integer(kind=c_size_t) :: pass_shape(1)
       integer(kind=c_int)    :: inocopy,iconst
       pass_shape=(/0/)
       if(present(nocopy)) then
         if(nocopy) then
           inocopy=1
         endif
       else
         inocopy=0
       endif
       if(present(const)) then
         if(const) then
           iconst=1
         endif
       else
         iconst=0
       endif
       if(present(error) .or. present(ierror)) then
         call plumed_f_cmd_safe_nothrow_ptr(p,key,val,pass_shape,iconst,inocopy,c_loc(myerror),c_funloc(plumed_f_eh))
         if(present(error)) then
           error=myerror
         endif
         if(present(ierror)) then
           ierror=myerror%code
         endif
       else
         call plumed_f_cmd_safe_nothrow_ptr(p,key,val,pass_shape,iconst,inocopy,c_null_ptr,c_null_ptr)
       endif
     end subroutine plumed_f_cmd_ptr

     subroutine plumed_f_gcmd_ptr(key,val,dummy,error,ierror,const,nocopy)
       character(kind=c_char,len=*),  intent(in)    :: key
       type(c_ptr),                      value      :: val
       type(dummy_type),   optional                 :: dummy
       type(plumed_error), optional,  intent(out)   :: error
       integer,            optional,  intent(out)   :: ierror
       logical,            optional,  intent(in)    :: const
       logical,            optional,  intent(in)    :: nocopy
       character(kind=c_char,len=32) :: global
       call plumed_f_global(global)
       call plumed_f_cmd(global,key,val,error=error,ierror=ierror,const=const,nocopy=nocopy)
     end subroutine plumed_f_gcmd_ptr

     subroutine plumed_f_cmd_char(p,key,val,dummy,error,ierror,const,nocopy)
       character(kind=c_char,len=32), intent(in)    :: p
       character(kind=c_char,len=*),  intent(in)    :: key
       character(kind=c_char,len=*), asynchronous   :: val
       type(dummy_type),   optional                 :: dummy
       type(plumed_error), optional,  intent(out)   :: error
       integer,            optional,  intent(out)   :: ierror
       logical,            optional,  intent(in)    :: const
       logical,            optional,  intent(in)    :: nocopy
       type(plumed_error), target :: myerror
       integer(kind=c_size_t) :: pass_shape(2)
       integer(kind=c_int)    :: inocopy,iconst
       pass_shape=(/len(val),0/)
       if(present(nocopy)) then
         if(nocopy) then
           inocopy=1
         endif
       else
         inocopy=0
       endif
       if(present(const)) then
         if(const) then
           iconst=1
         endif
       else
         iconst=0
       endif
       if(present(error) .or. present(ierror)) then
         call plumed_f_cmd_safe_nothrow_char(p,key,val,pass_shape,iconst,inocopy,c_loc(myerror),c_funloc(plumed_f_eh))
         if(present(error)) then
           error=myerror
         endif
         if(present(ierror)) then
           ierror=myerror%code
         endif
       else
         call plumed_f_cmd_safe_nothrow_char(p,key,val,pass_shape,iconst,inocopy,c_null_ptr,c_null_ptr)
       endif
     end subroutine plumed_f_cmd_char

     subroutine plumed_f_gcmd_char(key,val,dummy,error,ierror,nocopy)
       character(kind=c_char,len=*),  intent(in)    :: key
       character(kind=c_char,len=*), asynchronous   :: val
       type(dummy_type),   optional                 :: dummy
       type(plumed_error), optional,  intent(out)   :: error
       integer,            optional,  intent(out)   :: ierror
       logical,            optional,  intent(in)    :: nocopy
       character(kind=c_char,len=32) :: global
       call plumed_f_global(global)
       call plumed_f_cmd(global,key,val,error=error,ierror=ierror)
     end subroutine plumed_f_gcmd_char

#: for t in types
#: for ik in range(len(kinds[t]))
#: set k = kinds[t][ik]
#: for r in range(maxrank+1)
    subroutine plumed_f_cmd_${t}$_${ik}$_${r}$(p,key,val,dummy,error,ierror,const,nocopy)
      character(kind=c_char,len=32), intent(in)    :: p
      character(kind=c_char,len=*),  intent(in)    :: key
      ${t}$(KIND=${k}$), asynchronous              :: val${ranksuffix(r)}$
       type(dummy_type),   optional                 :: dummy
      type(plumed_error), optional,  intent(out)   :: error
      integer,            optional,  intent(out)   :: ierror
      logical,            optional,  intent(in)    :: const
      logical,            optional,  intent(in)    :: nocopy
      type(plumed_error), target :: myerror
      integer(kind=c_int)    :: inocopy,iconst
#: if r==0
#: set scalar = "_scalar"
      integer(kind=c_size_t) :: pass_shape(2)
      pass_shape=(/1,0/)
#: else
#: set scalar = ""
      integer(kind=c_size_t) :: pass_shape(${r+1}$)
#: for rr in range(r)
      pass_shape(${rr+1}$)=size(val,${r-rr}$)
#: endfor
      pass_shape(${r+1}$)=0
#: endif
       if(present(nocopy)) then
         if(nocopy) then
           inocopy=1
         endif
       else
         inocopy=0
       endif
       if(present(const)) then
         if(const) then
           iconst=1
         endif
       else
         iconst=0
       endif
       if(present(error) .or. present(ierror)) then
         call plumed_f_cmd_safe_nothrow_${cname(k)}$${scalar}$(p,key,val,pass_shape,iconst,inocopy,c_loc(myerror),c_funloc(plumed_f_eh))
         if(present(error)) then
           error=myerror
         endif
         if(present(ierror)) then
           ierror=myerror%code
         endif
       else
         call plumed_f_cmd_safe_nothrow_${cname(k)}$${scalar}$(p,key,val,pass_shape,iconst,inocopy,c_null_ptr,c_null_ptr)
       endif
    end subroutine plumed_f_cmd_${t}$_${ik}$_${r}$
    subroutine plumed_f_gcmd_${t}$_${ik}$_${r}$(key,val,dummy,error,ierror,nocopy)
      character(kind=c_char,len=*),  intent(in)    :: key
      ${t}$(kind=${k}$), asynchronous              :: val${ranksuffix(r)}$
      type(dummy_type),   optional                 :: dummy
      type(plumed_error), optional,  intent(out)   :: error
      integer,            optional,  intent(out)   :: ierror
      logical,            optional,  intent(in)    :: nocopy
      character(kind=c_char,len=32) :: global
      call plumed_f_global(global)
      call plumed_f_cmd(global,key,val,error=error,ierror=ierror,nocopy=nocopy)
    end subroutine plumed_f_gcmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor

end module plumed_module

